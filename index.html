<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyseur de MobilitÃ© - Dashboard</title>

    <!-- BibliothÃ¨ques distantes -->
    <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        :root {
            --primary: #4facfe;
            --secondary: #00f2fe;
            --bg: #f8fafc;
            --card-bg: #ffffff;
            --text: #1e293b;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 1.2rem;
            color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 10;
        }

        .search-bar {
            display: flex;
            gap: 10px;
            max-width: 900px;
            margin: 0.8rem auto 0;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
        }

        input {
            flex: 1;
            padding: 10px 15px;
            border-radius: 8px;
            border: none;
            outline: none;
            font-size: 0.9rem;
        }

        button.btn-load {
            background: #1e293b;
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        button.btn-load:hover { background: #334155; transform: translateY(-1px); }

        main {
            display: grid;
            grid-template-columns: 420px 1fr;
            flex: 1;
            overflow: hidden;
        }

        .side-panel {
            padding: 20px;
            background: var(--card-bg);
            border-right: 1px solid #e2e8f0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            border: 1px solid #f1f5f9;
        }

        .controls {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .toggle-btn {
            flex: 1;
            padding: 8px;
            border-radius: 20px;
            border: 1px solid #e2e8f0;
            background: white;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            transition: 0.2s;
        }

        .toggle-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .bike-toggle {
            background: #f0fdf4;
            color: #16a34a;
            border: 1px solid #bbf7d0;
        }

        .bike-toggle.active { background: #22c55e; color: white; }

        .chart-container { height: 250px; position: relative; }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .stat-item {
            text-align: center;
            padding: 12px;
            background: #f8fafc;
            border-radius: 10px;
        }

        .stat-val { font-size: 1.1rem; font-weight: 700; color: var(--primary); }
        .stat-lab { font-size: 0.65rem; color: #64748b; text-transform: uppercase; }

        #map-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #f0f0f0;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(255,255,255,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
            gap: 10px;
        }

        .spinner {
            width: 40px; height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="loading-overlay" id="global-loader">
        <div class="spinner"></div>
        <div id="loader-msg">Recherche des donnÃ©es...</div>
    </div>

    <header>
        <div style="text-align:center;">
            <h1 style="margin:0; font-size: 1.3rem;">ðŸ“Š Analyseur de MobilitÃ©</h1>
        </div>
        <div class="search-bar">
            <input type="text" id="input-site" placeholder="Entreprise (ex: Monoprix)" />
            <input type="text" id="input-city" placeholder="Ville (ex: Bordeaux)" />
            <button class="btn-load" onclick="App.initFetch()">Charger</button>
        </div>
    </header>

    <main>
        <div class="side-panel">
            <div class="card">
                <div class="controls">
                    <button class="toggle-btn active" id="btn-dist" onclick="App.setMode('distance')">Distance (km)</button>
                    <button class="toggle-btn" id="btn-time" onclick="App.setMode('time')">Temps (min)</button>
                    <button class="toggle-btn bike-toggle" id="btn-bike" onclick="App.toggleBike()">Mode VAE</button>
                </div>
                <div class="chart-container">
                    <canvas id="mainChart"></canvas>
                </div>
            </div>

            <div class="card">
                <div class="stats-grid" id="stats-grid"></div>
            </div>

            <div id="console-logs" style="font-size: 0.7rem; font-family: monospace; color: #64748b; padding: 10px; border-top: 1px solid #f1f5f9; max-height: 200px; overflow-y: auto; background: #fdfdfd; border-radius: 8px;">
                > PrÃªt pour l'analyse...
            </div>
        </div>

        <div id="map-container"></div>
    </main>

    <script>
        // URL MISE Ã€ JOUR SELON VOTRE DERNIER MESSAGE
        const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbxNrmW4mTLR6O1GUIdmxFkbA6iQ7h3aNxs2gdOrMPfbxleVQqi8Oslq9Disgk3h2ZnKyA/exec";

        const App = {
            state: {
                mode: 'distance',
                bikeEnabled: false,
                rawData: [],
                mapLayers: { points: null, lines: null },
                chart: null
            },

            log(msg, type = 'info') {
                const logs = document.getElementById('console-logs');
                const time = new Date().toLocaleTimeString();
                logs.innerHTML += `<br><span style="color: ${type === 'error' ? '#ef4444' : '#64748b'}">[${time}] ${msg}</span>`;
                logs.scrollTop = logs.scrollHeight;
                console.log(`[${type.toUpperCase()}] ${msg}`);
            },

            showLoader(show, msg = "Chargement...") {
                const loader = document.getElementById('global-loader');
                document.getElementById('loader-msg').innerText = msg;
                loader.style.display = show ? 'flex' : 'none';
            },

            async initFetch() {
                const site = document.getElementById('input-site').value.trim();
                const city = document.getElementById('input-city').value.trim();

                if (!site || !city) {
                    alert("Veuillez saisir une entreprise et une ville.");
                    return;
                }

                this.showLoader(true, "Lecture de la base Sheets...");
                this.log(`Recherche : ${site} Ã  ${city}`);

                try {
                    const fetchUrl = `${SCRIPT_URL}?site=${encodeURIComponent(site)}&city=${encodeURIComponent(city)}`;
                    const response = await fetch(fetchUrl);
                    const result = await response.json();

                    if (!result || result.status === 'error') {
                        throw new Error(result.message || "Aucune donnÃ©e trouvÃ©e.");
                    }

                    this.log("DonnÃ©es JSON reÃ§ues.");
                    this.processData(result.data);

                } catch (err) {
                    this.log(`Erreur critique : ${err.message}`, 'error');
                } finally {
                    this.showLoader(false);
                }
            },

            processData(row) {
                if (!row) {
                    this.log("Erreur : L'objet 'data' est vide.", "error");
                    return;
                }

                this.log("DÃ©codage des couches gÃ©ographiques...");
                
                const parseGeo = (input) => {
                    try {
                        let data = typeof input === 'string' ? JSON.parse(input) : input;
                        // Si c'est un tableau de 1 Ã©lÃ©ment (comme dans votre exemple), on extrait l'objet
                        if (Array.isArray(data)) return data[0];
                        return data;
                    } catch (e) {
                        this.log("Ã‰chec parsing JSON d'une colonne carto", "error");
                        return null;
                    }
                };

                this.state.mapLayers.points = parseGeo(row.field3);
                this.state.mapLayers.lines = parseGeo(row.field4);

                if (!this.state.mapLayers.points || !this.state.mapLayers.lines) {
                    this.log("Attention : Certaines couches carto sont invalides.", "error");
                }

                this.log("Traitement du CSV d'analyse...");
                Papa.parse(row.field5, {
                    header: true,
                    dynamicTyping: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        this.state.rawData = results.data;
                        this.log(`${results.data.length} lignes de donnÃ©es traitÃ©es.`);
                        this.renderAll();
                    }
                });
            },

            renderAll() {
                this.updateChart();
                this.renderMap();
            },

            setMode(m) {
                this.state.mode = m;
                document.getElementById('btn-dist').classList.toggle('active', m === 'distance');
                document.getElementById('btn-time').classList.toggle('active', m === 'time');
                this.updateChart();
            },

            toggleBike() {
                this.state.bikeEnabled = !this.state.bikeEnabled;
                document.getElementById('btn-bike').classList.toggle('active', this.state.bikeEnabled);
                this.updateChart();
            },

            updateChart() {
                const bins = this.state.mode === 'distance' 
                    ? { '0-2km': 0, '2-5km': 0, '5-10km': 0, '10km+': 0 }
                    : { '0-10m': 0, '10-15m': 0, '15-20m': 0, '20m+': 0 };

                this.state.rawData.forEach(d => {
                    if (this.state.mode === 'distance') {
                        const val = d.distance_km;
                        if (val <= 2) bins['0-2km']++;
                        else if (val <= 5) bins['2-5km']++;
                        else if (val <= 10) bins['5-10km']++;
                        else bins['10km+']++;
                    } else {
                        let val = d.duration_minutes;
                        if (this.state.bikeEnabled) val *= 0.75;
                        if (val <= 10) bins['0-10m']++;
                        else if (val <= 15) bins['10-15m']++;
                        else if (val <= 20) bins['15-20m']++;
                        else bins['20m+']++;
                    }
                });

                const labels = Object.keys(bins);
                const values = Object.values(bins);

                const grid = document.getElementById('stats-grid');
                grid.innerHTML = labels.map((l, i) => `
                    <div class="stat-item">
                        <div class="stat-val">${values[i]}</div>
                        <div class="stat-lab">${l}</div>
                    </div>
                `).join('');

                const ctx = document.getElementById('mainChart').getContext('2d');
                if (this.state.chart) this.state.chart.destroy();
                
                this.state.chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: values,
                            backgroundColor: this.state.bikeEnabled ? '#22c55e' : '#4facfe',
                            borderRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: { y: { beginAtZero: true }, x: { grid: { display: false } } }
                    }
                });
            },

            renderMap() {
                if (!this.state.mapLayers.lines) return;
                this.log("Mise Ã  jour de Deck.gl...");

                const layers = [
                    // FOND DE CARTE OSM VOYAGER (CORRECTION)
                    new deck.TileLayer({
                        id: 'base-tiles',
                        data: 'https://basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
                        minZoom: 0,
                        maxZoom: 19,
                        tileSize: 256,
                        renderSubLayers: props => {
                            const { bbox: { west, south, east, north } } = props.tile;
                            return new deck.BitmapLayer(props, {
                                data: null,
                                image: props.data,
                                bounds: [west, south, east, north]
                            });
                        }
                    }),
                    // HEATMAP (BasÃ©e sur les points de dÃ©part du fichier heat)
                    new deck.HeatmapLayer({
                        id: 'heatmap',
                        data: this.state.mapLayers.points ? this.state.mapLayers.points.features : [],
                        getPosition: d => d.geometry.coordinates,
                        getWeight: 1,
                        radiusPixels: 45,
                        intensity: 1,
                        threshold: 0.05
                    }),
                    // ROUTES GEOJSON
                    new deck.GeoJsonLayer({
                        id: 'geojson-lines',
                        data: this.state.mapLayers.lines,
                        stroked: true,
                        lineWidthMinPixels: 2,
                        getLineColor: [79, 172, 254, 180],
                        pickable: true
                    })
                ];

                if (!this.deckgl) {
                    this.deckgl = new deck.DeckGL({
                        container: 'map-container',
                        initialViewState: {
                            longitude: -0.57, latitude: 44.83, // Bordeaux par dÃ©faut
                            zoom: 11, pitch: 0, bearing: 0
                        },
                        controller: true,
                        layers: layers
                    });
                } else {
                    this.deckgl.setProps({ layers: layers });
                }

                // Auto-center sur le premier point
                if (this.state.mapLayers.points?.features?.length > 0) {
                    const center = this.state.mapLayers.points.features[0].geometry.coordinates;
                    this.deckgl.setProps({
                        initialViewState: {
                            longitude: center[0], latitude: center[1],
                            zoom: 11, transitionDuration: 800
                        }
                    });
                }
            }
        };

        window.addEventListener('resize', () => {
            if (App.deckgl) App.deckgl.setProps({ width: '100%', height: '100%' });
        });
    </script>
</body>
</html>
